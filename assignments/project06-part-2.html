<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Project06 Part 2 | CS 315 - Computer Architecture</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="Project06 Part 2" />
<meta name="author" content="Phil Peterson" />
<meta property="og:locale" content="en_US" />
<meta property="og:site_name" content="CS 315 - Computer Architecture" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-05-12T18:45:50+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Project06 Part 2" />
<script type="application/ld+json">
{"url":"/assignments/project06-part-2.html","@type":"BlogPosting","headline":"Project06 Part 2","dateModified":"2022-05-12T18:45:50+00:00","datePublished":"2022-05-12T18:45:50+00:00","author":{"@type":"Person","name":"Phil Peterson"},"mainEntityOfPage":{"@type":"WebPage","@id":"/assignments/project06-part-2.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="CS 315 - Computer Architecture" /><head>
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">  
</head>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">CS 315 - Computer Architecture</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/help/">Getting Help</a><a class="page-link" href="/syllabus/">Syllabus</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper"><h1 class="page-heading">Project06 Part 2</h1><div class="container"><hr>
  <section id="main_content">
    
<p><img src="/assets/img/project06/extender.png" alt="extender" /></p>

<p>The extender will perform sign extension of 8- and 12-bit unsigned immediate values (that is, zero extension out to 32 bits) and 24 bit signed branch offsets (that is, test bit 23 and extend its value out to 32 bits)</p>

<p>Inputs</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">iw</code> (32 bits) the current instruction word</li>
  <li><code class="language-plaintext highlighter-rouge">ExtOp</code> (2 bits) the extender selector, which selects between
    <ul>
      <li>00: 8-bit zero extension. Concatenate the low 8 bits with 24 bits of 0 to output a 32-bit value</li>
      <li>01: 12-bit zero extension. Concatenate the low 12 bits with 20 bits of 0 to output a 32-bit value</li>
      <li>10: 24 bit sign extension. Recall from Project04 that the 24-bit branch offset is expressed in words, and the PC is expressed in bytes. Therefore you must multiply the sign-extended value by 4 as you did in Project04. This can be accomplished using Digital’s Barrel Shifter or Multiply components.</li>
    </ul>
  </li>
</ol>

<p>Outputs</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">extimm</code> (32 bits) the extended value</li>
</ol>

<p><img src="/assets/img/project06/data-memory.png" alt="data-memory" /></p>

<ol>
  <li>Our programs will need access to RAM, e.g., the stack, arrays, etc.</li>
  <li>We will use the component with separate load(<code class="language-plaintext highlighter-rouge">ld</code>) and store (<code class="language-plaintext highlighter-rouge">str</code>) inputs.</li>
  <li>We will configure the RAM for 32 data bits, which means we can load and store only 32-bit values.</li>
  <li>You will configure the number of address bits based on the amount of stack space your test programs need. Recursive functions may use quite a bit of stack space</li>
</ol>

<p>Inputs</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">A</code> (you figure out how many bits you need): the input address for the read or write to memory</li>
  <li><code class="language-plaintext highlighter-rouge">Din</code> (32 bits): the value to be written to memory when <code class="language-plaintext highlighter-rouge">str</code> is 1</li>
  <li><code class="language-plaintext highlighter-rouge">str</code> (1 bit): set to 1 if we are storing (writing) to memory</li>
  <li><code class="language-plaintext highlighter-rouge">C</code> (1 bit): clock input</li>
  <li><code class="language-plaintext highlighter-rouge">ld</code> (1 bit) set to 1 if we are loading (reading) from memory</li>
</ol>

<p>Outputs</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">D</code> (32 bits): the data value we read from memory at address <code class="language-plaintext highlighter-rouge">A</code></li>
  <li>As with the ROM, we are only supporting word addresses. Therefore, when calculating a target memory address for <code class="language-plaintext highlighter-rouge">ldr</code> or <code class="language-plaintext highlighter-rouge">str</code> instructions, we need to convert the byte address into a word address before sending it to the RAM component</li>
  <li>In addition, we need to ensure that the target address is the same as the number of bits in the <code class="language-plaintext highlighter-rouge">A</code> input</li>
</ol>

<h2 id="adding-control-and-data-paths">Adding Control and Data Paths</h2>

<p>In this post and in upcoming lectures, we will discuss a methodology for identifying instructions and splitting off the bits of the instruction word to interpret what the instruction means. Once we have a circuit which represents the meaning of the instruction, we can use that to make decisions about how to select and direct data on the data path and determine the control inputs to the processor components such as the register file and ALU.</p>

<p>To start, let’s use this short program:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>first_s:
    mov r0, #1
    mov r1, #2
    add r2, r0, r1
    add r0, r0, #0
</code></pre></div></div>
<p>To execute these instructions we need to:</p>

<ol>
  <li>Add a data path for the <code class="language-plaintext highlighter-rouge">add</code> instruction word coming out of the ROM. In the schematic below, that’s shown with bits 0-3 (<code class="language-plaintext highlighter-rouge">rm</code>) going into <code class="language-plaintext highlighter-rouge">ReadReg0</code>, bits 12-15 (<code class="language-plaintext highlighter-rouge">rn</code>) going into <code class="language-plaintext highlighter-rouge">ReadReg1</code>, and bits 16-19 (<code class="language-plaintext highlighter-rouge">rd</code>) going into <code class="language-plaintext highlighter-rouge">WriteReg</code></li>
  <li>Add a data path for the mov instruction. In the schematic, that’s shown using the iw tunnel coming out of the ROM, and into the Extension Unit.</li>
  <li>Add an initial Decoder (Control Unit) to choose between adding registers and moving immediate data. The schematic shows the output of that decision in <code class="language-plaintext highlighter-rouge">ALUop</code>, which is the selector into the ALU.</li>
  <li>Now you can execute the mov and add instructions to put 1 + 2 = 3 in r2</li>
</ol>

<p><img src="/assets/img/project06/control-data.png" alt="control-data" /></p>

<h2 id="developing-the-control-unit">Developing the Control Unit</h2>

<p>We will build the circuit for the control unit using the digital logic gates we learned about in Project05. To build the requirements, we will use a truth-table-like spreadsheet:</p>

<p><img src="/assets/img/project06/spreadsheet-1.png" alt="spreadsheet-1" /></p>

<p>Using the Instruction Set Manual,</p>
<ol>
  <li>We can identify bits 27 and 26 from the instruction word for data processing instructions, recall if these are set to 00, then the instruction is possibly a data processing instruction.</li>
  <li>We can identify the Data Processing opcode in bits 24-21. Add is 0b0100 and mov is 0b1101.</li>
</ol>

<p>We will use a simple model for outputs for the control unit:</p>
<ol>
  <li>Since the Register File has a <code class="language-plaintext highlighter-rouge">WriteEn</code> control input, let’s make up a <code class="language-plaintext highlighter-rouge">RFW</code> (Register File Write) output to match it up with. <code class="language-plaintext highlighter-rouge">RFW</code> will be 1 when we identify an instruction which needs to write to the register file</li>
  <li>Since the Extender needs a control input to select its operations, let’s make up an <code class="language-plaintext highlighter-rouge">EXTop</code> output to match it up with. The values coming out of EXTop will be
    <ul>
      <li><code class="language-plaintext highlighter-rouge">0b00</code>: 8-bit zero-extended immediate</li>
      <li><code class="language-plaintext highlighter-rouge">0b01</code>: 12-bit zero-extended memory address</li>
      <li><code class="language-plaintext highlighter-rouge">0b10</code>: 24-bit sign-extended branch offset</li>
      <li><code class="language-plaintext highlighter-rouge">0b11</code>: 5-bit zero-extended shift immediate</li>
    </ul>
  </li>
  <li>Since the ALU needs a control input to select its operations, let’s make up an <code class="language-plaintext highlighter-rouge">ALUop</code> to select arithmetic instructions in the ALU. The values coming out of ALUop will be:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">0b000</code>: addition</li>
      <li><code class="language-plaintext highlighter-rouge">0b001</code>: subtraction</li>
      <li><code class="language-plaintext highlighter-rouge">0b010</code>: multiplication</li>
      <li><code class="language-plaintext highlighter-rouge">0b011</code>: move</li>
    </ul>
  </li>
  <li>Since we need a way to differentiate between ALU operations which use registers vs. those which use immediate values, we will make up a data output to send to the Extender Unit, and call it <code class="language-plaintext highlighter-rouge">ALUsrcB</code></li>
</ol>

<p>This schematic shows how to construct gates which match the spreadsheet above, and can execute the <code class="language-plaintext highlighter-rouge">first_s.s</code> program above. You will add instructions to the spreadsheet, which may involve new inputs and outputs, and add build a circuit like this within your Control Unit</p>

<p><img src="/assets/img/project06/control-v1.png" alt="control-v1" /></p>

<h2 id="adding-support-for-bl-and-bx">Adding Support for <code class="language-plaintext highlighter-rouge">bl</code> and <code class="language-plaintext highlighter-rouge">bx</code></h2>

<p>Now that you can execute <code class="language-plaintext highlighter-rouge">add</code> and <code class="language-plaintext highlighter-rouge">mov</code> instructions, let’s move on to a version which supports <code class="language-plaintext highlighter-rouge">bl</code> and <code class="language-plaintext highlighter-rouge">bx</code>, as implemented in <code class="language-plaintext highlighter-rouge">first_main.s</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>main:
    mov r0, #1
    mov r1, #2
    bl first_s
    add r0, r0, #0
first_s:
    add r0, r0, r1
    bx lr
</code></pre></div></div>

<p>To support branch, we need to modify the data path and the control path, as well as the control unit. In the schematic, that’s shown with the branch multiplexer choosing PC + 4 or a branch target calculated by the ALU</p>

<p>See the following new top-level processor circuit with an updated datapath and control path. Note that we have added several MUXes that allow us to direct traffic. For example,</p>
<ol>
  <li>The MUX control by <code class="language-plaintext highlighter-rouge">PCsel</code> will choose which value to send to the PC. For normal instructions this will be PC+4, for <code class="language-plaintext highlighter-rouge">b</code> and <code class="language-plaintext highlighter-rouge">bl</code> this will be the Branch Target Address that is computed using the ALU, and for BX.</li>
  <li>The MUX controlled by <code class="language-plaintext highlighter-rouge">RR0sel</code> now chooses between <code class="language-plaintext highlighter-rouge">rn</code> for data processing instructions and <code class="language-plaintext highlighter-rouge">0xF</code> (the PC) for the branch target calculation.</li>
  <li>The MUX controlled by <code class="language-plaintext highlighter-rouge">RR1sel</code> has been added for supporting future instructions not currently supported in this version.</li>
  <li>The MUX controlled by <code class="language-plaintext highlighter-rouge">WRsel</code> chooses between <code class="language-plaintext highlighter-rouge">rd</code> and <code class="language-plaintext highlighter-rouge">0xE</code> (<code class="language-plaintext highlighter-rouge">LR</code>) for which register to write to</li>
  <li>The MUX controlled by <code class="language-plaintext highlighter-rouge">WDsel</code> chooses between the ALU Result and PC+4 as for input into <code class="language-plaintext highlighter-rouge">WriteData</code>.</li>
</ol>

<p><img src="/assets/img/project06/muxes.png" alt="muxes" /></p>

<p>To support these instructions, we need to also evolve the Decoder (Control Unit) to control the new MUXes and new components. The spreadsheet below shows new inputs and outputs for these instructions. Note that an X input means “don’t care” – that is it could be 0 or 1. So we can ignore “don’t care” values when detecting an instruction type.</p>

<p><img src="/assets/img/project06/spreadsheet-2.png" alt="spreadsheet-2" /></p>

<p>When we identify branch instructions those will output the PC value on <code class="language-plaintext highlighter-rouge">RD0</code>, and choose the next PC value coming from the ALU result on the data path. That result will be the branch target address. <code class="language-plaintext highlighter-rouge">bx</code> chooses the value in the register number found in bits 3-0 (<code class="language-plaintext highlighter-rouge">rn</code>).</p>

<p>This table adds rows for adding an immediate value and moving a register value. It also adds new control lines for <code class="language-plaintext highlighter-rouge">bl</code> and <code class="language-plaintext highlighter-rouge">bx</code>. The schematic below shows how to add those inputs and outputs to our Control Unit circuit. Instead of using constant values and a MUX for the output bits, we can use a ROM instead. In this way you can copy the output bits from the spreadsheet into the contents of the ROM. In this example, the ROM has 3 address bit and 16 data bits. When editing the ROM contents you can cut and paste the output bit column and paste it directly into the contents.</p>

<p><img src="/assets/img/project06/decode-rom.png" alt="decode-rom" /></p>

  </section>
</div>

      </div>
    </main>

  </body>

</html>
